// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const CreateAlarmEvent = `-- name: CreateAlarmEvent :execresult
INSERT INTO history_event (Object, AlarmCategoryOrder, HighestAlarmCategory, AlarmMessage, AckMessage, start_time)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateAlarmEventParams struct {
	Object               string    `json:"object"`
	Alarmcategoryorder   int32     `json:"alarmcategoryorder"`
	Highestalarmcategory string    `json:"highestalarmcategory"`
	Alarmmessage         string    `json:"alarmmessage"`
	Ackmessage           string    `json:"ackmessage"`
	StartTime            time.Time `json:"start_time"`
}

func (q *Queries) CreateAlarmEvent(ctx context.Context, arg CreateAlarmEventParams) (sql.Result, error) {
	return q.exec(ctx, q.createAlarmEventStmt, CreateAlarmEvent,
		arg.Object,
		arg.Alarmcategoryorder,
		arg.Highestalarmcategory,
		arg.Alarmmessage,
		arg.Ackmessage,
		arg.StartTime,
	)
}

const CreateAlarmEventDetail = `-- name: CreateAlarmEventDetail :execresult
INSERT INTO history_event_detail (Event_id, Object, AlarmCategory, created_at)
VALUES (?, ?, ?, ?)
`

type CreateAlarmEventDetailParams struct {
	EventID       int32     `json:"event_id"`
	Object        string    `json:"object"`
	Alarmcategory string    `json:"alarmcategory"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) CreateAlarmEventDetail(ctx context.Context, arg CreateAlarmEventDetailParams) (sql.Result, error) {
	return q.exec(ctx, q.createAlarmEventDetailStmt, CreateAlarmEventDetail,
		arg.EventID,
		arg.Object,
		arg.Alarmcategory,
		arg.CreatedAt,
	)
}

const CreateRule = `-- name: CreateRule :execresult
INSERT INTO rules (object, AlarmCategoryOrder, AlarmLogic, TriggerValue, AlarmCategory, AlarmMessage, AckMethod)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateRuleParams struct {
	Object             string `json:"object"`
	Alarmcategoryorder int32  `json:"alarmcategoryorder"`
	Alarmlogic         string `json:"alarmlogic"`
	Triggervalue       string `json:"triggervalue"`
	Alarmcategory      string `json:"alarmcategory"`
	Alarmmessage       string `json:"alarmmessage"`
	Ackmethod          string `json:"ackmethod"`
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) (sql.Result, error) {
	return q.exec(ctx, q.createRuleStmt, CreateRule,
		arg.Object,
		arg.Alarmcategoryorder,
		arg.Alarmlogic,
		arg.Triggervalue,
		arg.Alarmcategory,
		arg.Alarmmessage,
		arg.Ackmethod,
	)
}

const DeleteRule = `-- name: DeleteRule :exec
DELETE
FROM rules
WHERE id = ?
`

func (q *Queries) DeleteRule(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteRuleStmt, DeleteRule, id)
	return err
}

const ListAllActiveAlarms = `-- name: ListAllActiveAlarms :many
SELECT id, object, alarmcategoryorder, highestalarmcategory, alarmmessage, ackmessage, start_time, end_time
FROM history_event
where end_time is null
`

func (q *Queries) ListAllActiveAlarms(ctx context.Context) ([]HistoryEvent, error) {
	rows, err := q.query(ctx, q.listAllActiveAlarmsStmt, ListAllActiveAlarms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HistoryEvent
	for rows.Next() {
		var i HistoryEvent
		if err := rows.Scan(
			&i.ID,
			&i.Object,
			&i.Alarmcategoryorder,
			&i.Highestalarmcategory,
			&i.Alarmmessage,
			&i.Ackmessage,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllHistoryBaseOnStartTime = `-- name: ListAllHistoryBaseOnStartTime :many
SELECT id, object, alarmcategoryorder, highestalarmcategory, alarmmessage, ackmessage, start_time, end_time
FROM history_event
where start_time >= ?
  and start_time < ?
`

type ListAllHistoryBaseOnStartTimeParams struct {
	StartTime   time.Time `json:"start_time"`
	StartTime_2 time.Time `json:"start_time_2"`
}

func (q *Queries) ListAllHistoryBaseOnStartTime(ctx context.Context, arg ListAllHistoryBaseOnStartTimeParams) ([]HistoryEvent, error) {
	rows, err := q.query(ctx, q.listAllHistoryBaseOnStartTimeStmt, ListAllHistoryBaseOnStartTime, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HistoryEvent
	for rows.Next() {
		var i HistoryEvent
		if err := rows.Scan(
			&i.ID,
			&i.Object,
			&i.Alarmcategoryorder,
			&i.Highestalarmcategory,
			&i.Alarmmessage,
			&i.Ackmessage,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAllRules = `-- name: ListAllRules :many
SELECT id, object, alarmcategoryorder, alarmlogic, triggervalue, alarmcategory, alarmmessage, ackmethod, created_at
FROM rules
`

func (q *Queries) ListAllRules(ctx context.Context) ([]Rule, error) {
	rows, err := q.query(ctx, q.listAllRulesStmt, ListAllRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.Object,
			&i.Alarmcategoryorder,
			&i.Alarmlogic,
			&i.Triggervalue,
			&i.Alarmcategory,
			&i.Alarmmessage,
			&i.Ackmethod,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetAlarmEventEndTime = `-- name: SetAlarmEventEndTime :exec
UPDATE history_event
SET end_time = ?
where id = ?
  and end_time is null
`

type SetAlarmEventEndTimeParams struct {
	EndTime sql.NullTime `json:"end_time"`
	ID      int32        `json:"id"`
}

func (q *Queries) SetAlarmEventEndTime(ctx context.Context, arg SetAlarmEventEndTimeParams) error {
	_, err := q.exec(ctx, q.setAlarmEventEndTimeStmt, SetAlarmEventEndTime, arg.EndTime, arg.ID)
	return err
}

const TruncateRules = `-- name: TruncateRules :exec
TRUNCATE rules
`

func (q *Queries) TruncateRules(ctx context.Context) error {
	_, err := q.exec(ctx, q.truncateRulesStmt, TruncateRules)
	return err
}

const UpdateAlarmAckMessage = `-- name: UpdateAlarmAckMessage :exec
UPDATE history_event
SET AckMessage = ?
where id = ?
  and end_time is null
`

type UpdateAlarmAckMessageParams struct {
	Ackmessage string `json:"ackmessage"`
	ID         int32  `json:"id"`
}

func (q *Queries) UpdateAlarmAckMessage(ctx context.Context, arg UpdateAlarmAckMessageParams) error {
	_, err := q.exec(ctx, q.updateAlarmAckMessageStmt, UpdateAlarmAckMessage, arg.Ackmessage, arg.ID)
	return err
}

const UpdateRule = `-- name: UpdateRule :exec
UPDATE rules
set AlarmCategoryOrder=?,
    AlarmLogic=?,
    TriggerValue=?,
    AlarmCategory=?,
    AlarmMessage=?,
    AckMethod=?,
    created_at=?
WHERE id = ?
`

type UpdateRuleParams struct {
	Alarmcategoryorder int32     `json:"alarmcategoryorder"`
	Alarmlogic         string    `json:"alarmlogic"`
	Triggervalue       string    `json:"triggervalue"`
	Alarmcategory      string    `json:"alarmcategory"`
	Alarmmessage       string    `json:"alarmmessage"`
	Ackmethod          string    `json:"ackmethod"`
	CreatedAt          time.Time `json:"created_at"`
	ID                 int32     `json:"id"`
}

func (q *Queries) UpdateRule(ctx context.Context, arg UpdateRuleParams) error {
	_, err := q.exec(ctx, q.updateRuleStmt, UpdateRule,
		arg.Alarmcategoryorder,
		arg.Alarmlogic,
		arg.Triggervalue,
		arg.Alarmcategory,
		arg.Alarmmessage,
		arg.Ackmethod,
		arg.CreatedAt,
		arg.ID,
	)
	return err
}

const UpgradeAlarmCategory = `-- name: UpgradeAlarmCategory :exec
UPDATE history_event
SET AlarmCategoryOrder   = ?,
    HighestAlarmCategory = ?,
    AlarmMessage         =?
where id = ?
  and end_time is null
`

type UpgradeAlarmCategoryParams struct {
	Alarmcategoryorder   int32  `json:"alarmcategoryorder"`
	Highestalarmcategory string `json:"highestalarmcategory"`
	Alarmmessage         string `json:"alarmmessage"`
	ID                   int32  `json:"id"`
}

func (q *Queries) UpgradeAlarmCategory(ctx context.Context, arg UpgradeAlarmCategoryParams) error {
	_, err := q.exec(ctx, q.upgradeAlarmCategoryStmt, UpgradeAlarmCategory,
		arg.Alarmcategoryorder,
		arg.Highestalarmcategory,
		arg.Alarmmessage,
		arg.ID,
	)
	return err
}
